import { _, assert } from "spec.ts"
import {
  ExtendedModel,
  fromSnapshot,
  getSnapshot,
  idProp,
  Model,
  ModelIdPropertyName,
  modelIdKey,
  runUnprotected,
  SnapshotInOf,
  SnapshotOutOf,
} from "../../src"
import { testModel } from "../utils"

const generatorOverrideError =
  "expected same idProp.withGenerator function when overriding a base idProp"

test("ids", () => {
  const modelType = "ids/ids"

  @testModel("ids")
  class M extends Model({
    [modelIdKey]: idProp,
  }) {}

  const expectState = (m: M, expectedId: string) => {
    expect(m.$modelId).toBe(expectedId)
    expect(m.getRefId()).toBe(m.$modelId)
    expect(getSnapshot(m)).toEqual({
      $modelId: m.$modelId,
      $modelType: modelType,
    } as SnapshotOutOf<M>)
  }

  const autoGenerated = new M({})
  expectState(autoGenerated, "id-1")

  const provided = new M({ $modelId: "MY_ID" })
  expectState(provided, "MY_ID")

  const from = fromSnapshot(M, { $modelType: modelType, $modelId: "MY_ID2" })
  expectState(from, "MY_ID2")
  const roundtrip = fromSnapshot(M, getSnapshot(from))
  expectState(roundtrip, "MY_ID2")

  const mutable = new M({})
  expectState(mutable, "id-2")
  expect(mutable.$.$modelId).toBe("id-2")
  runUnprotected(() => {
    mutable.$modelId = "MY_ID"
  })
  expectState(mutable, "MY_ID")
  expect(mutable.$.$modelId).toBe("MY_ID")
})

test("ids with custom property", () => {
  const modelType = "ids with custom property/ids-customProperty"

  @testModel("ids-customProperty")
  class M extends Model({
    id: idProp.withSetter(),
  }) {}

  const expectState = (m: M, expectedId: string) => {
    expect(m.$modelId).toBe(expectedId)
    expect(m.id).toBe(m.$modelId)
    expect(m.getRefId()).toBe(m.$modelId)
    expect(m.$.id).toBe(expectedId)
    expect((m.$ as any).$modelId).toBe(undefined)
    expect(getSnapshot(m)).toEqual({
      id: m.$modelId,
      $modelType: modelType,
    } as SnapshotOutOf<M>)
  }

  const autoGenerated = new M({})
  expectState(autoGenerated, "id-1")

  const provided = new M({ id: "MY_ID" })
  expectState(provided, "MY_ID")

  const from = fromSnapshot(M, { $modelType: modelType, id: "MY_ID2" })
  expectState(from, "MY_ID2")
  const roundtrip = fromSnapshot(M, getSnapshot(from))
  expectState(roundtrip, "MY_ID2")

  const mutable = new M({})
  expectState(mutable, "id-2")
  runUnprotected(() => {
    mutable.$modelId = "MY_ID"
  })
  expectState(mutable, "MY_ID")

  mutable.setId("MY_ID2")
  expectState(mutable, "MY_ID2")
})

test("extended class from base with custom id", () => {
  @testModel("IdOnBase")
  class IdOnBase extends Model({
    id: idProp,
  }) {}

  assert(_ as ModelIdPropertyName<IdOnBase>, _ as "id")

  @testModel("ExtendedIdOnBase")
  class ExtendedIdOnBase extends ExtendedModel(IdOnBase, {}) {}

  assert(_ as ModelIdPropertyName<ExtendedIdOnBase>, _ as "id")

  const m1 = new ExtendedIdOnBase({ id: "MY_ID" })
  expect(m1.$modelId).toBe("MY_ID")
  expect(m1.id).toBe(m1.$modelId)
  expect(m1.getRefId()).toBe(m1.$modelId)
  expect(m1.$.id).toBe("MY_ID")
  expect((m1.$ as any).$modelId).toBe(undefined)
})

test("idProp.withGenerator", () => {
  let nextId = 1
  const generator = () => `custom-${nextId++}`

  @testModel("ModelWithCustomIdGenerator")
  class ModelWithCustomIdGenerator extends Model({
    id: idProp.withGenerator(generator).withSetter(),
  }) {}

  const m1 = new ModelWithCustomIdGenerator({})
  expect(m1.id).toBe("custom-1")
  expect(m1.$modelId).toBe("custom-1")

  m1.setId("MY_ID")
  expect(m1.id).toBe("MY_ID")
  expect(m1.$modelId).toBe("MY_ID")

  const m2 = new ModelWithCustomIdGenerator({ id: "MY_ID" })
  expect(m2.id).toBe("MY_ID")
  expect(m2.$modelId).toBe("MY_ID")

  const m3 = fromSnapshot(ModelWithCustomIdGenerator, getSnapshot(m1), { generateNewIds: true })
  expect(m3.id).toBe("custom-2")
  expect(m3.$modelId).toBe("custom-2")
})

test("idProp.withGenerator with chaining and typedAs", () => {
  type Id = `typed-${string}`

  let nextId = 1
  const generator = () => `typed-${nextId++}` as Id

  @testModel("ModelWithTypedIdGenerator")
  class ModelWithTypedIdGenerator extends Model({
    id: idProp.withSetter().withGenerator(generator).typedAs<Id>(),
  }) {}

  const m = new ModelWithTypedIdGenerator({})
  expect(m.id).toBe("typed-1")
  m.setId("typed-2")
  assert(m.id, _ as Id)
  assert(m.$modelId, _ as Id)
})

test("idProp.withSetter(fn) transforms assigned value", () => {
  @testModel("ModelWithIdSetterTransform")
  class ModelWithIdSetterTransform extends Model({
    id: idProp.withSetter((id) => id.toUpperCase()),
  }) {}

  const m = new ModelWithIdSetterTransform({})

  m.setId("custom-id")

  expect(m.id).toBe("CUSTOM-ID")
  expect(m.$modelId).toBe("CUSTOM-ID")
  expect(getSnapshot(m)).toEqual({
    id: "CUSTOM-ID",
    $modelType: "idProp.withSetter(fn) transforms assigned value/ModelWithIdSetterTransform",
  })
})

test("idProp.withGenerator in ExtendedModel", () => {
  let nextBaseId = 1
  const baseGenerator = () => `base-${nextBaseId++}`

  @testModel("BaseWithGenerator")
  class BaseWithGenerator extends Model({
    id: idProp.withGenerator(baseGenerator),
  }) {}

  @testModel("ExtendedUsesBaseGenerator")
  class ExtendedUsesBaseGenerator extends ExtendedModel(BaseWithGenerator, {}) {}

  expect(new ExtendedUsesBaseGenerator({}).id).toBe("base-1")

  let nextExtendedId = 1
  const extendedGenerator = () => `extended-${nextExtendedId++}`

  @testModel("BaseWithoutGenerator")
  class BaseWithoutGenerator extends Model({
    id: idProp,
  }) {}

  expect(() => {
    class _ extends ExtendedModel(BaseWithoutGenerator, {
      id: idProp.withGenerator(extendedGenerator),
    }) {}
    return _
  }).toThrow(generatorOverrideError)

  expect(() => {
    class _ extends ExtendedModel(BaseWithGenerator, {
      id: idProp.withSetter(),
    }) {}
    return _
  }).toThrow(generatorOverrideError)

  @testModel("ExtendedUsesSameGeneratorAsBase")
  class ExtendedUsesSameGeneratorAsBase extends ExtendedModel(BaseWithGenerator, {
    id: idProp.withGenerator(baseGenerator),
  }) {}

  expect(new ExtendedUsesSameGeneratorAsBase({}).id).toBe("base-2")

  expect(() => {
    class _ extends ExtendedModel(BaseWithGenerator, {
      id: idProp.withGenerator(extendedGenerator),
    }) {}
    return _
  }).toThrow(generatorOverrideError)
})

test("idProp.withGenerator in ExtendedModel when base has no idProp", () => {
  let nextId = 1
  const generator = () => `model-${nextId++}`

  @testModel("BaseWithoutIdField")
  class BaseWithoutIdField extends Model({}) {}

  @testModel("ExtendedAddsIdWithGenerator")
  class ExtendedAddsIdWithGenerator extends ExtendedModel(BaseWithoutIdField, {
    id: idProp.withGenerator(generator),
  }) {}

  const m = new ExtendedAddsIdWithGenerator({})
  expect(m.id).toBe("model-1")
})

test("idProp.typedAs", () => {
  type Id = `custom-${string}`
  @testModel("M")
  class M extends Model({
    id: idProp.typedAs<Id>(),
  }) {}

  const m = new M({ id: "custom-1" })
  assert(m.id, _ as Id)
  assert(_ as SnapshotInOf<M>["id"], _ as Id | undefined)
  assert(_ as SnapshotOutOf<M>["id"], _ as Id)
  assert(m.$modelId, _ as Id)
})
