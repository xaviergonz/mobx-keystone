---
name: References
route: /references
---

# References

## Overview

As we saw in the [tree-like structure](./treeLikeStructure) section, a same non-primitve node can only be in a single tree and only once.
This means that for example if we wanted to have a list of todos and a selected todo we would need to have the same node repeated twice (once in the list and then once again in a selected field).

References allows us to work around this limitation by making a "fake" node that is just a pointer to another model in the same root tree.

Given the example above we could model it like this:

```ts
@model("myApp/TodoList")
class TodoList extends Model<{ list: Todo[]; selected?: Ref<Todo> }> {
  // ...

  @modelAction
  selectTodo(todo: Todo | undefined) {
    if (!this.$.list.includes(todo)) {
      throw new Error("cannot select a todo that is not in the list")
    }
    this.$.selected = todo ? ref(todo) : undefined
  }
}
```

Reference objects offer the following properties:

- `current` - The model this reference points to, or throws if it could not be found in the same tree.
- `maybeCurrent` - The model this reference points to, or undefined if it could not be found in the same tree.
- `isValid` - If the reference is valid, this is, if the referenced model object is not part of the same tree than the reference.
- `id` - Unique model ID this reference points to.

## Auto-detachable references

Sometimes (as in the example above) it is also desireable for a reference to get auto-detached when the original no longer exists. For this purpose the `ref` method accepts an options object with an option named `autoDetach`, which defaults to false.

The `autoDetach` option, when set to true (default is false), allows the reference to auto-detach itself from its parent (using `detach`) as soon as it becomes invalid while being attached to a root store. Note that for the option to work the root object must be registered as a root store using `registerAsRootStore`.

```ts
@model("myApp/TodoList")
class TodoList extends Model<{ list: Todo[]; selected?: Ref<Todo> }> {
  // ...

  @modelAction
  selectTodo(todo: Todo | undefined) {
    if (!this.$.list.includes(todo)) {
      throw new Error("cannot select a todo that is not in the list")
    }
    this.$.selected = todo ? ref(todo, { autoDetach: true }) : undefined
  }
}

// for this to work the reference must live under a root store
const todoList = newModel(TodoList, {})
registerRootStore(todoList)

// now if we delete the selected todo from the array, then `selected`
// will become undefined
```

`autoDetach` will work differently depending on the reference container:

- Model/object property: the property will be deleted (therefore remember to type the property as optional in Typescript).
- Array item: the array item will be removed (therefore no need to type the array items as possibly undefined in Typescript).
