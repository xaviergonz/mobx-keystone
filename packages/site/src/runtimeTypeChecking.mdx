---
name: Runtime Type Checking
route: /runtimeTypeChecking
---

# Runtime Type Checking

## Overview

While `mobx-data-model` was built with first class Typescript support in mind, it is also possible to enforce runtime type checking.
This feature is, however, **completely optional**. This is, if you are happy with the type safety that Typescript offers at compilation time you are free to stick to it exclusively.

# Type definitions

Type definitions are like the schemas for your data. They are usually associated with models like this:

```ts
const todoDataType = types.object(() => ({
  text: types.string,
  done: types.boolean,
}))

// TypeToData<typeof todoDataType> =
// {
//   text: string,
//   done: boolean
// }

@model("TodoApp/Todo", { dataType: todoDataType })
class Todo extends Model<TypeToData<typeof todoDataType>> {
  defaultData = {
    done: false, // marks done as an optional property
  }

  // ...
}
```

In this case whenever the model is created / changed it will be automatically type checked in development mode and will throw an exception if the change results in a model that does not pass the checking.

If you want to enforce checkins no matter if `process.env.NODE_ENV` is set to production or not you can do so like this:

```ts
setGlobalConfig({
  modelAutoTypeChecking: ModelAutoTypeCheckingMode.AlwaysOn,
})
```

The possible values are:

- `ModelAutoTypeCheckingMode.DevModeOnly` - Auto type check models only in dev mode
- `ModelAutoTypeCheckingMode.AlwaysOn` - Auto type check models no matter the current environment
- `ModelAutoTypeCheckingMode.AlwaysOff` - Do not auto type check models no matter the current environment

It is also possible to trigger type checking manually:

```ts
const myTodo = newModel(Todo, { text: "hi" })
const checkError = myTodo.typeCheck()
// or
const todoType = types.model<Todo>(Todo)
const checkError = typeCheck(todoType, myTodo)

// also possible with non models
const numberArrayType = types.array(types.number)
const checkError = typeCheck(numberArrayType, [1, 2, 3])
```

In all cases the returned value will be null if there are no errors or an instance of `TypeCheckError`, which will include:

- `path: ReadonlyArray<string | number>` - Sub-path where the type check failed, or an empty array if the actual object/value passed failed the type check.
- `expectedTypeName: string` - String representation of the expected type.
- `actualValue: any` - The actual value/sub-value that failed the type check
- `throw(typeCheckedValue: any)` - Throws the error as an exception.

While models are usually automatically type-checked, it is worth noting that other values (primitives, plain objects, arrays) are not until they become attached to some model. If you need to type check those before they become attached to a model it is always possible to use `typeCheck(type, value)` as shown previously to trigger a manual validation.

## Types

These are the possible types:

### `types.literal`

A type that represents a certain value of a primitive (for example an _exact_ number or string).

```ts
const hiType = types.literal("hi") // the string with value "hi"
const number5Type = types.literal(5) // the number with value 5
```

### `types.undefined`

A type that represents the value undefined.

```ts
types.undefined
```

### `types.null`

A type that represents the value null.

```ts
types.undefined
```

### `types.boolean`

A type that represents any boolean value.

```ts
types.boolean
```

### `types.number`

A type that represents any number value.

```ts
types.number
```

### `types.string`

A type that represents any string value.

```ts
types.string
```

### `types.enum`

An enum type, based on a Typescript alike enum object.

```ts
enum Color {
  Red = "red",
  Green = "green",
}

const colorType = types.enum<Color>(Color)
```

### `types.or` (AKA union)

A type that represents the union of several other types (a | b | c | ...).

```ts
const booleanOrNumberType = types.or(types.boolean, types.number)
```

### `types.maybe`

A type that represents either a type or undefined.

```ts
const numberOrUndefinedType = types.maybe(types.number)
```

### `types.maybeNull`

A type that represents either a type or null.

```ts
const numberOrNullType = types.maybeNull(types.number)
```

### `types.object`

A type that represents a plain object.
Note that the parameter must be a function that returns an object. This is done so objects can support self / cross types.

```ts
// notice the ({ ... }), not just { ... }
types.object(() => ({
  x: types.number,
  y: types.number,
}))
```

### `types.array`

A type that represents an array of values of a given type.

```ts
const numberArrayType = types.array(types.number)
```

### `types.objectMap`

A type that represents an object-like map, an object with string keys and values all of a same given type.

```ts
// { [k: string]: number }
const numberMapType = types.objectMap(types.number)
```

### `types.model`

A type that represents a model. The type referenced in the model decorator will be used for type checking.

```ts
const someModelType = types.model<SomeModel>(SomeModel)
```

### `types.unchecked`

A type that represents a given value that won't be type checked.
This is basically a way to bail out of the runtime type checking system.

```ts
const uncheckedSomeModel = types.unchecked<SomeModel>()
const anyType = types.unchecked<any>()
const customUncheckedType = types.unchecked<(A & B) | C>()
```

### `types.ref`

A type that represents a reference to a model.

```ts
const refToSomeModelType = types.ref<SomeModel>()
```

### `types.frozen`

A type that represents frozen data.

```ts
const frozenNumberType = types.frozen(types.number)
const frozenAnyType = types.frozen(types.unchecked<any>())
const frozenNumberArrayType = types.frozen(types.array(types.number))
const frozenUncheckedNumberArrayType = types.frozen(types.unchecked<number[]>())
```

# Notes for `mobx-state-tree` users

- Typechecking in `mobx-data-model` is performed over instances once they have been created, not over snapshots, so the type definitions should be based on that fact.
- There is no `types.optional` since setting default values is already covered by the `defaultData` field of models.
- While models will automatically typecheck themselves upon changes, other types will be only type checked when they get attached to nodes. If for some reason you need to type check them before then manually use the `typeCheck` method.
